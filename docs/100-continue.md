

### 100-continue

특히 메시지 본문이 매우 클 때나 클라이언트가 오류 응답을 예상할 때(예: 처음으로 상태를 변경하는 메소드를 보내거나 인증 정보를 확인하지 않았을 때), 이 메커니즘은 매우 유용합니다. 클라이언트는 서버가 본문을 수신할 준비가 되었는지 확인한 후에 데이터를 보내므로, 대역폭 낭비를 막을 수 있습니다.

- https://datatracker.ietf.org/doc/html/rfc7231#section-5.1.1
- Expect Header에는 반드시 100-continue만 와야함. (대소문자 구분하지 않음.)
- 그 외에 다른 값이 올 경우 417로 Response.
- 다음과 같이 동작하는 것을 의미함.
  - 클라이언트는 큰 Body를 보내려고 함. 
  - 중간 응답으로 서버가 100을 내려주기를 기다림.


### 클라이언트 측.
- 클라이언트는 Body가 없을 때 100-continue 쓰면 안됨.
- 100 Response를 기다릴 클라이언트는 Expect: 100-contiue를 보내야함.
- Expect: 100-continue를 보낸 클라이언트는 특정 시간 동안 응답을 기다릴 필요가 없고, 응답을 받지 못했더라도 메세지 본문을 보낼 수 있음. 
- HTTP/1.0 서버는 이것을 처리할 수 없기 때문에 무한히 기다리면 안됨. 
- Expect: 100-continue로 보냈는데, 417 응답을 받은 클라이언트는 동일한 요청에서 Expect: 100-continue를 제거하고 다시 보내야 함. 



### 서버 측.
- Expect 헤더의 Value는 대소문자를 구별하지 않음.  
- 100-continue 말고 다른 값을 받으면 417 Expectation Failed를 응답해라. 
- HTTP/1.0에서 100-continue는 무시해야함. 
- 이미 Body를 받았거나, Body가 없는 경우 100 Continue Response를 생략할 수 있다. 즉, 최종 상태 코드를 응답할 수 있따.
- 서버가 100 Continue 응답을 보낸 후에는, 메세지 본문을 모두 수신하고 처리한 후 반드시 최종 상태 코드를 응답해야 함. 
